import { io } from 'socket.io-client';

class WebSocketService {
  constructor() {
    this.socket = null;
    this.isConnected = false;
    this.subscribedInstances = new Set();
    this.currentWorkspaceUuid = null;
    this.eventListeners = new Map();
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 5;
    this.reconnectDelay = 1000; // 1 segundo inicial
    this.fallbackMode = false; // Modo fallback para polling
    this.lastConnectionTime = null;
    this.connectionQuality = 'good'; // good, poor, failed
    this.healthCheckInterval = null;
    this.reconnectTimeout = null;
  }

  /**
   * Conectar ao servidor WebSocket
   */
  connect(workspaceUuid) {
    if (this.socket && this.isConnected) {
      console.log('üîå WebSocket j√° conectado');
      return Promise.resolve();
    }

    return new Promise((resolve, reject) => {
      try {
        console.log('üîÑ Conectando ao WebSocket...');

        this.currentWorkspaceUuid = workspaceUuid;

        // Configurar conex√£o
        this.socket = io(import.meta.env.VITE_API_BASE_URL || 'http://localhost:3001', {
          transports: ['websocket', 'polling'],
          timeout: 20000,
          autoConnect: true,
          reconnection: true,
          reconnectionAttempts: this.maxReconnectAttempts,
          reconnectionDelay: this.reconnectDelay,
          forceNew: false
        });

        // Eventos de conex√£o
        this.socket.on('connect', () => {
          console.log('‚úÖ WebSocket conectado:', this.socket.id);
          this.isConnected = true;
          this.reconnectAttempts = 0;
          this.fallbackMode = false;
          this.lastConnectionTime = new Date();
          this.connectionQuality = 'good';
          this.startHealthCheck();

          // Reinscrever em inst√¢ncias ap√≥s reconex√£o
          this.resubscribeToInstances();

          resolve();
        });

        this.socket.on('connected', (data) => {
          console.log('üéâ Confirma√ß√£o de conex√£o:', data);
        });

        this.socket.on('disconnect', (reason) => {
          console.log('üîå WebSocket desconectado:', reason);
          this.isConnected = false;
          this.connectionQuality = 'failed';
          this.stopHealthCheck();

          // Ativar modo fallback imediatamente
          this.enableFallbackMode();

          // Tentar reconectar automaticamente
          if (reason !== 'io client disconnect') {
            this.handleReconnection();
          }
        });

        this.socket.on('connect_error', (error) => {
          console.error('‚ùå Erro de conex√£o WebSocket:', error);
          this.isConnected = false;
          this.connectionQuality = 'failed';

          // Ativar modo fallback
          this.enableFallbackMode();

          if (this.reconnectAttempts === 0) {
            reject(error);
          }
        });

        // Eventos de resposta do servidor
        this.socket.on('subscription-confirmed', (data) => {
          console.log('‚úÖ Inscri√ß√£o confirmada:', data);
          this.subscribedInstances.add(data.instanceName);
        });

        this.socket.on('unsubscription-confirmed', (data) => {
          console.log('‚úÖ Desinscri√ß√£o confirmada:', data);
          this.subscribedInstances.delete(data.instanceName);
        });

        this.socket.on('error', (error) => {
          console.error('‚ùå Erro WebSocket:', error);
        });

        // Eventos de dados
        this.setupDataEventListeners();

        // Ping/Pong para manter conex√£o viva
        this.socket.on('pong', () => {
          // console.log('üèì Pong recebido');
        });

        this.startPing();

      } catch (error) {
        console.error('‚ùå Erro ao conectar WebSocket:', error);
        reject(error);
      }
    });
  }

  /**
   * Configurar listeners para eventos de dados
   */
  setupDataEventListeners() {
    // Nova mensagem
    this.socket.on('new-message', (data) => {
      console.log('üí¨ Nova mensagem via WebSocket:', data);
      this.emitToListeners('new-message', data);
    });

    // Atualiza√ß√£o de mensagem
    this.socket.on('message-update', (data) => {
      console.log('üìù Atualiza√ß√£o de mensagem:', data);
      this.emitToListeners('message-update', data);
    });

    // Atualiza√ß√£o de conex√£o
    this.socket.on('connection-update', (data) => {
      console.log('üîó Atualiza√ß√£o de conex√£o:', data);
      this.emitToListeners('connection-update', data);
    });

    // Atualiza√ß√£o de contato
    this.socket.on('contact-update', (data) => {
      console.log('üë§ Atualiza√ß√£o de contato:', data);
      this.emitToListeners('contact-update', data);
    });

    // Mensagens marcadas como lidas
    this.socket.on('messages-marked-read', (data) => {
      console.log('‚úÖ Mensagens marcadas como lidas:', data);
      this.emitToListeners('messages-marked-read', data);
    });

    // Evento gen√©rico da Evolution
    this.socket.on('evolution-event', (data) => {
      console.log('üì® Evento Evolution:', data);
      this.emitToListeners('evolution-event', data);
    });
  }

  /**
   * Inscrever-se em uma inst√¢ncia
   */
  async subscribeToInstance(instanceName, validateInstance = true) {
    if (!this.socket || !this.isConnected) {
      console.warn('‚ö†Ô∏è WebSocket n√£o conectado para inscri√ß√£o');
      return false;
    }

    if (this.subscribedInstances.has(instanceName)) {
      console.log(`üìù J√° inscrito na inst√¢ncia: ${instanceName}`);
      return true;
    }

    // Validar se a inst√¢ncia √© v√°lida e pertence ao workspace
    if (validateInstance && this.currentWorkspaceUuid) {
      const isValid = await this.validateInstance(instanceName, this.currentWorkspaceUuid);
      if (!isValid) {
        console.warn(`‚ö†Ô∏è Inst√¢ncia ${instanceName} n√£o √© v√°lida para o workspace ${this.currentWorkspaceUuid}`);
        return false;
      }
    }

    console.log(`üìù Inscrevendo na inst√¢ncia: ${instanceName}`);

    this.socket.emit('subscribe-instance', {
      instanceName,
      workspaceUuid: this.currentWorkspaceUuid
    });

    return true;
  }

  /**
   * Validar se uma inst√¢ncia pertence ao workspace e est√° ativa
   */
  async validateInstance(instanceName, workspaceUuid) {
    try {
      // Fazer requisi√ß√£o para validar a inst√¢ncia
      const response = await fetch(`${import.meta.env.VITE_API_BASE_URL || 'http://localhost:3001'}/api/workspace-instances/validate`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          instanceName,
          workspaceUuid
        })
      });

      if (!response.ok) {
        console.warn(`‚ö†Ô∏è Falha na valida√ß√£o da inst√¢ncia ${instanceName}: ${response.status}`);
        return false;
      }

      const data = await response.json();
      const isValid = data.success && data.isValid;

      if (!isValid) {
        console.warn(`‚ö†Ô∏è Inst√¢ncia ${instanceName} n√£o √© v√°lida:`, data.reason);
      }

      return isValid;
    } catch (error) {
      console.error(`‚ùå Erro ao validar inst√¢ncia ${instanceName}:`, error);
      // Em caso de erro na valida√ß√£o, permitir inscri√ß√£o (fallback)
      return true;
    }
  }

  /**
   * Desinscrever-se de uma inst√¢ncia
   */
  unsubscribeFromInstance(instanceName) {
    if (!this.socket || !this.isConnected) {
      console.warn('‚ö†Ô∏è WebSocket n√£o conectado para desinscri√ß√£o');
      return false;
    }

    console.log(`üìù Desinscrevendo da inst√¢ncia: ${instanceName}`);

    this.socket.emit('unsubscribe-instance', {
      instanceName
    });

    this.subscribedInstances.delete(instanceName);
    return true;
  }

  /**
   * Marcar mensagens como lidas
   */
  markMessagesAsRead(instanceName, phoneNumber) {
    if (!this.socket || !this.isConnected) {
      console.warn('‚ö†Ô∏è WebSocket n√£o conectado para marcar como lido');
      return false;
    }

    this.socket.emit('mark-messages-read', {
      instanceName,
      phoneNumber
    });

    return true;
  }

  /**
   * Adicionar listener para eventos
   */
  addEventListener(event, callback) {
    if (!this.eventListeners.has(event)) {
      this.eventListeners.set(event, new Set());
    }
    this.eventListeners.get(event).add(callback);

    // Retornar fun√ß√£o para remover o listener
    return () => {
      this.removeEventListener(event, callback);
    };
  }

  /**
   * Remover listener de evento
   */
  removeEventListener(event, callback) {
    const listeners = this.eventListeners.get(event);
    if (listeners) {
      listeners.delete(callback);
      if (listeners.size === 0) {
        this.eventListeners.delete(event);
      }
    }
  }

  /**
   * Emitir evento para todos os listeners
   */
  emitToListeners(event, data) {
    const listeners = this.eventListeners.get(event);
    if (listeners) {
      listeners.forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          console.error(`‚ùå Erro no listener ${event}:`, error);
        }
      });
    }
  }

  /**
   * Iniciar ping peri√≥dico
   */
  startPing() {
    setInterval(() => {
      if (this.socket && this.isConnected) {
        this.socket.emit('ping');
      }
    }, 30000); // Ping a cada 30 segundos
  }

  /**
   * Manipular reconex√£o
   */
  handleReconnection() {
    if (this.reconnectTimeout) {
      clearTimeout(this.reconnectTimeout);
    }

    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++;
      const delay = Math.min(this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1), 30000); // Max 30s

      console.log(`üîÑ Tentativa de reconex√£o ${this.reconnectAttempts}/${this.maxReconnectAttempts} em ${delay}ms`);

      this.connectionQuality = 'poor';
      this.emitToListeners('connection-status', {
        status: 'reconnecting',
        attempt: this.reconnectAttempts,
        maxAttempts: this.maxReconnectAttempts
      });

      this.reconnectTimeout = setTimeout(() => {
        if (!this.isConnected) {
          this.connect(this.currentWorkspaceUuid).catch(error => {
            console.error('‚ùå Falha na reconex√£o:', error);
          });
        }
      }, delay);
    } else {
      console.error('‚ùå M√°ximo de tentativas de reconex√£o atingido - entrando em modo fallback permanente');
      this.enableFallbackMode(true); // Fallback permanente
      this.emitToListeners('connection-status', {
        status: 'failed',
        fallbackMode: true
      });
    }
  }

  /**
   * Desconectar WebSocket
   */
  disconnect() {
    if (this.socket) {
      console.log('üîå Desconectando WebSocket...');
      this.isConnected = false;
      this.subscribedInstances.clear();
      this.eventListeners.clear();
      this.stopHealthCheck();

      if (this.reconnectTimeout) {
        clearTimeout(this.reconnectTimeout);
      }

      this.socket.disconnect();
      this.socket = null;
    }
  }

  /**
   * Obter status da conex√£o
   */
  getStatus() {
    return {
      isConnected: this.isConnected,
      socketId: this.socket?.id,
      subscribedInstances: Array.from(this.subscribedInstances),
      workspaceUuid: this.currentWorkspaceUuid,
      eventListeners: Array.from(this.eventListeners.keys()),
      fallbackMode: this.fallbackMode,
      connectionQuality: this.connectionQuality,
      lastConnectionTime: this.lastConnectionTime,
      reconnectAttempts: this.reconnectAttempts
    };
  }

  /**
   * Reconectar manualmente
   */
  reconnect() {
    this.disconnect();
    this.reconnectAttempts = 0; // Reset attempts for manual reconnection
    this.fallbackMode = false;
    return this.connect(this.currentWorkspaceUuid);
  }

  /**
   * Ativar modo fallback para polling
   */
  enableFallbackMode(permanent = false) {
    this.fallbackMode = true;
    this.connectionQuality = 'failed';

    console.log(`‚ö†Ô∏è Modo fallback ${permanent ? 'permanente' : 'tempor√°rio'} ativado - usando polling`);

    this.emitToListeners('fallback-mode', {
      enabled: true,
      permanent,
      reason: 'websocket_disconnected'
    });
  }

  /**
   * Reinscres em inst√¢ncias ap√≥s reconex√£o
   */
  resubscribeToInstances() {
    if (this.subscribedInstances.size > 0) {
      console.log('üîÑ Reinscrevendo em inst√¢ncias ap√≥s reconex√£o...');
      const instances = Array.from(this.subscribedInstances);
      this.subscribedInstances.clear();

      instances.forEach(instanceName => {
        this.subscribeToInstance(instanceName);
      });
    }
  }

  /**
   * Iniciar verifica√ß√£o de sa√∫de da conex√£o
   */
  startHealthCheck() {
    this.stopHealthCheck(); // Limpar anterior

    this.healthCheckInterval = setInterval(() => {
      if (this.socket && this.isConnected) {
        const start = Date.now();

        this.socket.emit('ping', { timestamp: start });

        const timeout = setTimeout(() => {
          console.warn('‚ö†Ô∏è Health check timeout - conex√£o pode estar lenta');
          this.connectionQuality = 'poor';
        }, 5000);

        this.socket.once('pong', (data) => {
          clearTimeout(timeout);
          const latency = Date.now() - (data?.timestamp || start);

          this.connectionQuality = latency < 1000 ? 'good' : 'poor';

          this.emitToListeners('connection-health', {
            latency,
            quality: this.connectionQuality
          });
        });
      }
    }, 30000); // Check a cada 30 segundos
  }

  /**
   * Parar verifica√ß√£o de sa√∫de
   */
  stopHealthCheck() {
    if (this.healthCheckInterval) {
      clearInterval(this.healthCheckInterval);
      this.healthCheckInterval = null;
    }
  }

  /**
   * Verificar se est√° em modo fallback
   */
  isFallbackMode() {
    return this.fallbackMode;
  }

  /**
   * Verificar qualidade da conex√£o
   */
  getConnectionQuality() {
    return this.connectionQuality;
  }
}

// Inst√¢ncia singleton
const websocketService = new WebSocketService();

export default websocketService;